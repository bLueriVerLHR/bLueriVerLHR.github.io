# 分治策略

每当我们递归的求解一个问题，在每层递归中，应用如下三个步骤：

- **分解**（Divide）步骤将问题分为一些子问题，子问题的形式与原问题一样，只是规模更小。
- **解决**（Conquer）步骤递归地求解出子问题。如果子问题足够的小，则停止递归，直接求解。
- **合并**（Combine）步骤将子问题的解组合成原问题的解。

当子问题足够大，需要递归求解的时候，我们称之为**递归情况**（recursive case）。

当子问题变得足够小，不需要递归的时候，我们说递归已经“触底”了，进入了**基本情况**（base case）。

有时，子问题与原问题形式不完全一样的时候，我们将这些子问题的求解看作合并的一部分。

## 递归式

一个**递归式**（recurrence）就是一个不等式或等式，它通过更小的输入上的函数值来描述一个函数。

例如，我们知道[归并排序](./merge_sort.md)运行时间的递归式可以描述如下：

$$
T(n) = \left\{
\begin{aligned}
& \Theta (1)                    & if \space n = 1 \\
& 2T(\frac{n}{2})+\Theta (n)    & if \space n > 1
\end{aligned}
\right.
$$

求解可得到 $T(n)=\Theta(n\lg{n})$。

递归式可以有很多形式，递归算法可能会将问题划分为大小不等的多个子问题。例如：

$$T(n)=T(\frac{n}{3})+T(\frac{2n}{3})+\Theta(n)$$

子问题也不一定是原问题规模的一个固定的比例。例如，线性查找的递归版本，其递归式为：

$$T(n)=T(n-1)+\Theta(1)$$

---

接下来介绍三种求解递归式的方法，即得出算法的 $O$ 和 $\Theta$ 渐近界的方法：

- 代入法
    - 通过经验等猜测出一个界，然后用数学归纳法证明这个解是正确的。
- 递归树法
    - 将递归式，转换为一棵树，其结点表示不同层次的递归调用产生的代价。然后采用边界和技术来求解递归式。
- 主方法

主方法可求解形如下面公式的递归式的界

$$T(n) = aT(\frac{n}{b})+f(n)$$

其中 $a\geq 1$，$b>0$，$f(n)$ 是一个给定的函数。

这种形式的递归式很常见，它刻画了这样一个分治算法：生成 $a$ 个子问题，每个子问题都是原来问题的规模的 $1/b$ ，分解和合并步骤总共花费时间为 $f(n)$。

有些时候，会遇上用不等式刻画的递归式，我们需要使用 $O$ 或者 $\Omega$ 来表示。


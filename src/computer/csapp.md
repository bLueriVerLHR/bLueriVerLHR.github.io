# 一些基础

**计算机系统** 是由 `硬件` 和 `系统软件` 组成的。它们共同工作来运行应用程序。

# 源文件

计算机程序的生命周期是从一个 **源程序/源文件** 开始的，即程序员通过编辑器创建并保存文本文件。源程序本质上就是一个由值0和1组成的位（又称为比特）序列。8个位被组织成一组，称为 **字节**。每个字节表示程序中的某些文本字符。

大部分现代计算机系统都使用[ ASCII 标准](https://en.wikipedia.org/wiki/ASCII)来表示文本字符，该方式实际上就是用一个唯一的单字节大小的整数数值来表示每个字符。

> 由 ASCII 字符构成的文件称为文本文件，所有其他文件都称为二进制文件——《深入理解计算机系统（原书第3版）》

一份源代码的表示方式说明来一个基本思想：系统中所有的信息——包括磁盘文件、内存中的程序、内存中存放的用户数据以及网络上传送的数据，都是由一串比特表示的。区分不同数据对象的唯一方法是我们读到这些数据对象时候的上下文。

# 编译

一些程序的生命周期是从[ C 语言](https://en.wikipedia.org/wiki/C_(programming_language))程序开始的，因为这种形式能够被人读懂。

为了在系统上能够运行程序，每条 C 语句都必须被其他程序转化为一系列低级的[机器语言](https://en.wikipedia.org/wiki/Machine_code)指令。然后这些指令按照一种称为 **可执行目标程序** 的格式打包好，并以二进制磁盘文件的形式存放起来。目标程序也称为 **可执行目标文件**。

在 Unix 系统上，从源文件到目标文件的转化是由 **编译器驱动程序** 完成的。

例如 `main.c` 作为源文件，被编译器翻译的过程可以分为四个阶段：

```
-${main.c}-> [预处理器 cpp] -${main.i}-> [编译器 ccl] -${main.s}-> [汇编器 as] -${main.o}-> {链接器 ld} --> [可执行文件 main]
```

> 其中，链接器不止会链接 `main.o`，还会链接其他目标文件。

执行编译四个阶段的程序（预处理器、编译器、汇编器和链接器）一起构成了编译系统。

- **预处理阶段**。将宏展开，执行预处理指令，结果得到另一个 C 程序，通常是以 `.i` 作为文件拓展名。
- **编译阶段**。编译器将文本文件 `main.i` 翻译成文本文件 `main.s`，它包含一个汇编语言程序，该程序包含函数的定义。汇编语言为不同高级语言的不同编译器提供了通用的输出语言。
- **汇编阶段**。将 `main.s` 翻译成机器语言指令，把这些指令打包成一种叫做 **可重定位目标程序** 的格式。并将结果保存在目标文件 `main.o` 中。
- **链接阶段**。如果 `main` 程序调用了其他地方的函数，就可能会需要将对应的目标文件合并到 `main.o` 中。链接器就负责处理这种合并。结果生成 `main` 文件，它是一个 **可执行目标文件** 或者说 **可执行文件**，可以被加载到内存中，由系统执行。

# 硬件组成

## 总线

总线是一组贯穿整个系统的电子管道，它携带者信息字节并负责在各个部件间传递。通常总线被设计成传递定长的字节块，也就是 **字**。字中的字节数（即字长）是一个基本的系统参数。

## I/O设备

I/O（输入/输出）设备是系统与外部世界的联系通道。典型的输入设备就有键盘和鼠标，输出设备有屏幕和扬声器。

每个 I/O 设备都通过一个 **控制器** 或 **适配器** 与 I/O 总线相连。控制器和适配器之间的主要区别在于它们的封装方式。

- 控制器是 I/O 设备本身，或者系统的主印制电路板（通常称作主板）上的芯片组。
- 适配器则是一块插在主板插槽上的卡。

他们的功能是在 I/O 总线和 I/O 设备之间传递信息。

## 主存

主存是一个临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据。

- 从物理上讲，主存是一组动态 **随机存取存储器**（DRAM）芯片组成。
- 从逻辑上讲，粗藏尼虎棋是一个线性的字节数组，每个字节都有唯一的地址（数组索引），这些地址是从零开始的。

一般来说，组成程序的每条机器指令都由不同数量的字节构成。

## 处理器

中央处理单元（CPU），简称处理器，是解释（或执行）存储在主存中指令的引擎。处理器的核心是一个大小为一个字的存储设备（或寄存器），称为程序计数器（PC）。在任何时刻，PC 都指向主存中的某条机器语言指令（即含有该条指令的地址）。

处理器是按照一个指令执行模型来操作的，这个模型由 **指令集架构**（ISA）决定。在这个模型中，指令按照严格的顺序执行，而执行一条指令包含执行一系列的步骤。

从系统通电开始，直到系统断电，处理器一直在不断地从程序计数器指向的内存处读取指令，解释指令中的位，执行该指令指示的操作，然后更新 PC，使其指向下一条指令，而这条指令并不一定和在内存中刚刚执行的指令相邻。

这些操作主要围绕着主存、寄存器文件和算术/逻辑单元（ALU）进行。一般会包含如读、写、计算、跳转等操作。

处现代处理器使用了非常复杂的机制来加速程序的执行。因此，应该将处理器的 **指令集架构** 和处理器的 **微体系结构** 区分开来：

- 指令集架构描述的是每条机器代码指令的效果；
- 而微体系结构描述的是处理器实际上是如何实现的。

# 程序执行过程

当时用 shell 程序执行编译器生成的可执行程序的时候，shell 会通过一系列指令将可执行文件中的代码和数据从磁盘复制到主存。

利用 **直接存储器存取**（DMA）技术，数据可以不通过处理器而直接从磁盘到达主存。

当可执行文件加载到主存后，处理器就开始执行对应的机器语言指令。

该过程突出了一个显著的问题，即系统花费了大量的时间将信息从一个地方转移到另一个地方。

例如：

- 将可执行程序的内容加载到主存
- 将主存中的指令加载到处理器中
- 如果有 I/O 操作，还需要先将数据加载主存中，然后从主存中加载到 I/O 设备中。

从程序员角度来看，这些复制操作就是开销，减慢了程序“真正的”工作。

- 根据机械原理，较大的存储设备要比较小的存储设备运行的慢；
- 快速设备造价远高于同类的低速设备。

综合以上两点，系统设计者采用了 **高速缓存存储器**（cache memory，简称为 cache 或高速缓存），作为暂时的集结区域，存放处理器近期可能会需要的信息。

高速缓存用的是一种叫做静态随机访问存储器（SRAM）的硬件技术实现的。高速缓存可能有两极或者三级，这些存储器利用了高速缓存的 **局部性** 原理，提高了系统的访问速度。

# 存储设备形成层次结构

[传送](https://xxg1413.gitbooks.io/csapp/content/Chapter1/1.6.html)

# 操作系统管理硬件

当一些应用程序获取用户输入和往标准输出上显示数据的时候，都没有直接访问键盘和显示器。

它们依靠 **操作系统** 提供的服务进行这些操作。可以将操作系统看作应用程序和硬件之间插入的一层软件，所有应用程序对硬件的操作尝试都必须通过操作系统。

操作系统有两个基本功能：

1. 防止硬件被失控的应用程序滥用；
2. 向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备。

操作系统通过几个基本的抽象概念（进程、虚拟内存和文件）来实现以上两个功能。

- 文件是对 I/O 设备的抽象表示
- 虚拟内存是对主存和磁盘 I/O 设备的抽象表示
- 进程是对处理器、主存和 I/O 设备的抽象表示

> [Unix](https://en.wikipedia.org/wiki/Unix) [Posix](https://en.wikipedia.org/wiki/POSIX) [Single UNIX Specification](https://en.wikipedia.org/wiki/Single_UNIX_Specification)

## 进程

**进程** 是操作系统对一个正在运行的程序的一种抽象。在一个系统上可以同时运行多个进程，而每个进程都好像在独占地使用硬件。

**并发运行** 是说一个进程的指令和另一个进程的指令是交错执行的。

在大多数系统中，需要运行的进程是多于可以运行它们的 CPU 个数的。传统系统在一个时刻只能执行一个程序，而先进的多核处理器同时能够执行多个程序。无论是在单核还是多核系统中，一个 CPU 看上去都像是在并发的执行多个进程，这是通过处理器在进程间切换来实现的。操作系统实现这种交错执行的机制称为 **上下文切换**。

**上下文** 是操作系统保持跟踪进程运行所需的所有状态信息。包括比如 PC 和寄存器文件的当前值，以及主存的内容。

在任何时刻，单处理器系统都只能执行一个进程的代码。当操作系统决定要把控制权从当前进程转移到某个新进程时候，就会进行上下文切换，也即保存当前上下文、恢复新进程的上下文，然后将控制权传递到新进程。新进程就会从它上次停止的地方开始。

从一个进程到另一个进程的转换是由操作系统的内核管理的。内核是操作系统代码常驻主存的部分。当应用程序需要操作系统的某些操作时候，比如读写文件，它就执行一条特殊的 **系统调用**（system call）指令，将控制权传递给内核。然后内核执行被请求的操作并返回应用程序。

> 内核不是一个独立的进程。相反，它是系统管理全部进程所用的代码和数据结构的集合。

## 线程

在现代系统中，一个进程实际上可以由多个称为 **线程** 的执行单元，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据。

## 虚拟内存

**虚拟内存** 是一个抽象概念，它为每个进程提供一个假象，即每个进程都在独占地使用主存。每个进程看到的内存都是一致的，称为 **虚拟地址空间**。

> 用户栈是从高地址向低地址生长的。

虚拟地址空间组成（由低地址到高地址介绍）：

- **程序和数据段**。对所有进程来说，代码是从同一固定地址开始，接着是和 C 全局变量相对应的数据位置。代码和数据区是直接按照可执行目标文件的内容初始化的。